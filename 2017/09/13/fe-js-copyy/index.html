<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>js 中的浅拷贝和深拷贝 | HULEI BLOG - 凡心所向 素履所往 生如逆旅 一苇以航</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="hu lei"><meta name="keywords" content="undefined"><meta name="description" content="胡雷的个人博客是一个关注个人博客建设，WEB前端技术，开源云计算等技术信息博客，提供博主在学习成果和工作中经验总结，是一个互联网从业者值得收藏的网站。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta http-equiv="windows-Target" contect="_top"><link rel="canonical" href="http://dageger.cn/2017/09/13/fe-js-copyy/index.html"><link rel="icon" type="image/png" href="/img/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="胡雷的博客"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="胡雷的博客" alt="胡雷的博客"><img src="/img/logo.png" alt="胡雷的博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><header class="post__info"><h1 class="post__title">js 中的浅拷贝和深拷贝</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">DaGege</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2017-09-13</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/JS/">JS</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在读 zepto 的源码，深有感触，感觉随便一段代码都可以延伸出一大堆的知识点，在看到深拷贝和浅拷贝的时候，之前只是了解过什么是深拷贝什么是浅拷贝，并没有对齐实现进行探索，所以本文主要讲一下什么是深拷贝、什么是浅拷贝、深拷贝与浅拷贝的区别，以及怎么进行深拷贝和怎么进行浅拷贝</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>其实深拷贝和浅拷贝的主要区别就是其在内存中的存储类型不同。<br>堆和栈都是内存中划分出来用来存储的区域。</p><blockquote><p>栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。</p></blockquote><h2 id="ECMAScript-的数据类型"><a href="#ECMAScript-的数据类型" class="headerlink" title="ECMAScript 的数据类型"></a>ECMAScript 的数据类型</h2><p>在将深拷贝和浅拷贝之前，我们先来重新回顾一下 ECMAScript 中的数据类型。主要分为</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型主要是：undefined，boolean，number，string，null。</p><h3 id="基本数据类型存放在栈中"><a href="#基本数据类型存放在栈中" class="headerlink" title="基本数据类型存放在栈中"></a>基本数据类型存放在栈中</h3><p>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。</p><h3 id="基本数据类型值不可变"><a href="#基本数据类型值不可变" class="headerlink" title="基本数据类型值不可变"></a>基本数据类型值不可变</h3><blockquote><p>javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此 —— 改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像由字符组成的数组，我们期望可以通过指定索引来假改字符串中的字符。实际上，javascript 是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。</p></blockquote><p>基本数据类型的值是不可变的，动态修改了基本数据类型的值，它的原始值也是不会改变的，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span>;</div><div class="line"><span class="built_in">console</span>.log(str[<span class="number">1</span>]=<span class="string">"f"</span>);    <span class="comment">// f</span></div><div class="line"><span class="built_in">console</span>.log(str);           <span class="comment">// abc</span></div></pre></td></tr></table></figure><p></p><p>这一点其实开始我是比较迷惑的，总是感觉 js 是一个灵活的语言，任何值应该都是可变的，真是图样图森破，我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。就如上述引用所说的那样，在 js 中没有方法是可以改变布尔值和数字的。倒是有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。<br>所以，记住这一点：基本数据类型值不可变。</p><h3 id="基本类型的比较是值的比较"><a href="#基本类型的比较是值的比较" class="headerlink" title="基本类型的比较是值的比较"></a>基本类型的比较是值的比较</h3><p>基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(a === b);<span class="comment">//true</span></div></pre></td></tr></table></figure><p></p><p>比较的时候最好使用严格等，因为 == 是会进行类型转换的，比如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(a == b);<span class="comment">//true</span></div></pre></td></tr></table></figure><p></p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="基本数据类型存放在堆中"><a href="#基本数据类型存放在堆中" class="headerlink" title="基本数据类型存放在堆中"></a>基本数据类型存放在堆中</h3><p>引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配，例如。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;<span class="attr">name</span>:<span class="string">'jozo'</span>&#125;;</div><div class="line"><span class="keyword">var</span> person2 = &#123;<span class="attr">name</span>:<span class="string">'xiaom'</span>&#125;;</div><div class="line"><span class="keyword">var</span> person3 = &#123;<span class="attr">name</span>:<span class="string">'xiaoq'</span>&#125;;</div></pre></td></tr></table></figure><p><img src="./img-jsstack-1.png" alt=""></p><h3 id="引用类型值可变"><a href="#引用类型值可变" class="headerlink" title="引用类型值可变"></a>引用类型值可变</h3><p>引用类型是可以直接改变其值的，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">a[<span class="number">1</span>] = <span class="number">5</span>;</div><div class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]); <span class="comment">// 5</span></div></pre></td></tr></table></figure><p></p><h3 id="引用类型的比较是引用的比较"><a href="#引用类型的比较是引用的比较" class="headerlink" title="引用类型的比较是引用的比较"></a>引用类型的比较是引用的比较</h3><p>所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用（保存在栈内存中的指针），所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></div></pre></td></tr></table></figure><p>虽然变量 a 和变量 b 都是表示一个内容为 1，2，3 的数组，但是其在内存中的位置不一样，也就是说变量 a 和变量 b 指向的不是同一个对象，所以他们是不相等的。<br><img src="./img-jsstack-2.png" alt=""></p><h3 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h3><p>了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。<br>在我们进行img-jsstack-4.png类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = 10img-jsstack-4.png</div><div class="line">var b = a;img-jsstack-4.png</div><div class="line">a ++ ;</div><div class="line">console.log(a); // 11</div><div class="line">console.log(b); // 10</div></pre></td></tr></table></figure><p></p><p><img src="./img-jsstack-3.png" alt=""><br>所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。<br>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;; <span class="comment">// a保存了一个空对象的实例</span></div><div class="line"><span class="keyword">var</span> b = a;  <span class="comment">// a和b都指向了这个空对象</span></div><div class="line">a.name = <span class="string">'jozo'</span>;</div><div class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// 'jozo'</span></div><div class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">// 'jozo'</span></div><div class="line">b.age = <span class="number">22</span>;</div><div class="line"><span class="built_in">console</span>.log(b.age);<span class="comment">// 22</span></div><div class="line"><span class="built_in">console</span>.log(a.age);<span class="comment">// 22</span></div><div class="line"><span class="built_in">console</span>.log(a == b);<span class="comment">// true</span></div></pre></td></tr></table></figure><p></p><p><img src="./img-jsstack-4.png" alt=""></p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>在深入了解之前，我认为上面的赋值就是浅拷贝，哇哈哈，真的是图样图森破。上面那个应该只能算是“引用”，并不算是真正的浅拷贝。</p><p>一下部分参照知乎中的提问： <a href="https://www.zhihu.com/question/23031215" target="_blank" rel="external">javascript中的深拷贝和浅拷贝</a></p><h3 id="赋值（-）和浅拷贝的区别"><a href="#赋值（-）和浅拷贝的区别" class="headerlink" title="赋值（=）和浅拷贝的区别"></a>赋值（=）和浅拷贝的区别</h3><p>那么赋值和浅拷贝有什么区别呢，我们看下面这个例子：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    <span class="string">'name'</span> : <span class="string">'zhangsan'</span>,</div><div class="line">    <span class="string">'age'</span> :  <span class="string">'18'</span>,</div><div class="line">    <span class="string">'language'</span> : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]],</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line"><span class="keyword">var</span> obj3 = shallowCopy(obj1);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dst = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</div><div class="line">        <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</div><div class="line">            dst[prop] = src[prop];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dst;</div><div class="line">&#125;</div><div class="line">obj2.name = <span class="string">"lisi"</span>;</div><div class="line">obj3.age = <span class="string">"20"</span>;</div><div class="line">obj2.language[<span class="number">1</span>] = [<span class="string">"二"</span>,<span class="string">"三"</span>];</div><div class="line">obj3.language[<span class="number">2</span>] = [<span class="string">"四"</span>,<span class="string">"五"</span>];</div><div class="line"><span class="built_in">console</span>.log(obj1);  </div><div class="line"><span class="comment">//obj1 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'lisi',</span></div><div class="line"><span class="comment">//    'age' :  '18',</span></div><div class="line"><span class="comment">//    'language' : [1,[4,5]],</span></div><div class="line"><span class="comment">//&#125;;</span></div><div class="line"><span class="built_in">console</span>.log(obj2);</div><div class="line"><span class="comment">//obj2 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'lisi',</span></div><div class="line"><span class="comment">//    'age' :  '18',</span></div><div class="line"><span class="comment">//    'language' : [1,[4,5]],</span></div><div class="line"><span class="comment">//&#125;;</span></div><div class="line"><span class="built_in">console</span>.log(obj3);</div><div class="line"><span class="comment">//obj3 = &#123;</span></div><div class="line"><span class="comment">//    'name' : 'zhangsan',</span></div><div class="line"><span class="comment">//    'age' :  '20',</span></div><div class="line"><span class="comment">//    'language' : [1,[4,5]],</span></div><div class="line"><span class="comment">//&#125;;</span></div></pre></td></tr></table></figure><p></p><p>先定义个一个原始的对象 obj1，然后使用赋值得到第二个对象 obj2，然后通过浅拷贝，将 obj1 里面的属性都赋值到 obj3 中。也就是说：<br></p><ol><li>obj1：原始数据</li><li>obj2：赋值操作得到</li><li>obj3：浅拷贝得到</li></ol><p>然后我们改变 obj2 的 name 属性和 obj3 的 name 属性，可以看到，改变赋值得到的对象 obj2 同时也会改变原始值 obj1，而改变浅拷贝得到的的 obj3 则不会改变原始对象 obj1。这就可以说明赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是重新创建了新对象。<br><br>然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 obj2 和浅拷贝得到的 obj3 中的 language 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 obj2 和浅拷贝得到的 obj3 都会改变原始数据。<br><br>这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变。<br><br>深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象<br><br>浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象</p><table><thead><tr><th style="text-align:center">–</th><th style="text-align:center">和原数据是否指向同一对象</th><th>第一层数据为基本数据类型</th><th>原数据中包含子对象</th></tr></thead><tbody><tr><td style="text-align:center">赋值</td><td style="text-align:center">是</td><td>改变会使原数据一同改变</td><td>改变会使原数据一同改变</td></tr><tr><td style="text-align:center">浅拷贝</td><td style="text-align:center">否</td><td>改变不会使原数据一同改变</td><td>改变会使原数据一同改变</td></tr><tr><td style="text-align:center">深拷贝</td><td style="text-align:center">否</td><td>改变不会使原数据一同改变</td><td>改变不会使原数据一同改变</td></tr></tbody></table><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>看了这么半天，你也应该清楚什么是深拷贝了吧，如果还不清楚，我就剖腹自尽(?_?)<br><br>深拷贝是对对象以及对象的所有子对象进行拷贝。<br>那么问题来了，怎么进行深拷贝呢？<br>思路就是递归调用刚刚的浅拷贝，把所有属于对象的属性类型都遍历赋给另一个对象即可。我们直接来看一下 Zepto 中深拷贝的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/ 内部方法：用户合并一个或多个对象到第一个对象</div><div class="line"><span class="comment">// 参数：</span></div><div class="line"><span class="comment">// target 目标对象  对象都合并到target里</span></div><div class="line"><span class="comment">// source 合并对象</span></div><div class="line"><span class="comment">// deep 是否执行深度合并</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> source)</div><div class="line">        <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123;</div><div class="line">            <span class="comment">// source[key] 是对象，而 target[key] 不是对象， 则 target[key] = &#123;&#125; 初始化一下，否则递归会出错的</span></div><div class="line">            <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</div><div class="line">                target[key] = &#123;&#125;</div><div class="line">            <span class="comment">// source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的</span></div><div class="line">            <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key]))</div><div class="line">                target[key] = []</div><div class="line">            <span class="comment">// 执行递归</span></div><div class="line">            extend(target[key], source[key], deep)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</div><div class="line">&#125;</div><div class="line"><span class="comment">// Copy all but undefined properties from one or more</span></div><div class="line"><span class="comment">// objects to the `target` object.</span></div><div class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> deep, args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">    <span class="comment">//第一个参数为boolean值时，表示是否深度合并</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">'boolean'</span>) &#123;</div><div class="line">        deep = target;</div><div class="line">        <span class="comment">//target取第二个参数</span></div><div class="line">        target = args.shift()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历后面的参数，都合并到target上</span></div><div class="line">    args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123; extend(target, arg, deep) &#125;)</div><div class="line">    <span class="keyword">return</span> target</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 Zepto 中的 $.extend 方法判断的第一个参数传入的是一个布尔值，判断是否进行深拷贝。<br><br>在 $.extend 方法内部，只有一个形参 target，这个设计你真的很巧妙。<br>因为形参只有一个，所以 target 就是传入的第一个参数的值，并在函数内部设置一个变量 args 来接收去除第一个参数的其余参数，如果该值是一个布尔类型的值的话，说明要启用深拷贝，就将 deep 设置为 true，并将 target 赋值为 args 的第一个值（也就是真正的 target）。如果该值不是一个布尔类型的话，那么传入的第一个值仍为 target 不需要进行处理，只需要遍历使用 extend 方法就可以。<br><br>这里有点绕，但是真的设计的很精妙，建议自己打断点试一下，会有意外收获（玩转 js 的大神请忽略）。<br><br>而在 extend 的内部，是拷贝的过程。<br></p><div class="post-announce">感谢您的阅读，本文由 <a href="http://dageger.cn">胡雷的博客</a> 版权所有。如若转载，请注明出处：胡雷的博客（<a href="http://dageger.cn/2017/09/13/fe-js-copyy/">http://dageger.cn/2017/09/13/fe-js-copyy/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2017/09/04/fe-html-all-head/" title="2017年最新的head元素指南"><i class="iconfont icon-prev"></i>2017年最新的head元素指南</a></div><div class="post__prev post__prev--right"><a href="/2017/09/19/fe-css-border/" title="CSS中设置border属性为0与none的区别">CSS中设置border属性为0与none的区别<i class="iconfont icon-next"></i></a></div></div></div></article><script type="text/javascript">window.onload=function(){var o=Math.floor(5e3*Math.random());console.log(o),setTimeout(function(){window.location.reload()},o)}</script></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <button><i class="iconfont icon-search" for="submit"></i></button></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">胡雷的个人博客是一个关注个人博客建设，WEB前端技术，开源云计算等技术信息博客，提供博主在学习成果和工作中经验总结，是一个互联网从业者值得收藏的网站。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/后端/">后端</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/前端/">前端</a><span class="block-list-count">12</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/业界/">业界</a><span class="block-list-count">2</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/03/01/fe-web-http/" title="Web性能优化与HTTP/2"><div class="item__cover"><img src="/2018/03/01/fe-web-http/img-cover.jpg" alt="Web性能优化与HTTP/2"></div><div class="item__info"><h3 class="item__title">Web性能优化与HTTP/2</h3><span class="item__text">2018-03-01</span></div></a></li><li class="latest-post-item"><a href="/2017/12/20/fe-callapply/" title="快速理解JS中apply()和call()原理"><div class="item__cover"><img src="/2017/12/20/fe-callapply/cover.jpg" alt="快速理解JS中apply()和call()原理"></div><div class="item__info"><h3 class="item__title">快速理解JS中apply()和call()原理</h3><span class="item__text">2017-12-20</span></div></a></li><li class="latest-post-item"><a href="/2017/12/20/be-django-cms-install/" title="Django CMS教程"><div class="item__cover"><img src="/2017/12/20/be-django-cms-install/cover.png" alt="Django CMS教程"></div><div class="item__info"><h3 class="item__title">Django CMS教程</h3><span class="item__text">2017-12-20</span></div></a></li><li class="latest-post-item"><a href="/2017/12/17/fe-better-scroll/" title="Vue中better-scroll插件的使用"><div class="item__cover"><img src="/2017/12/17/fe-better-scroll/cover.jpg" alt="Vue中better-scroll插件的使用"></div><div class="item__info"><h3 class="item__title">Vue中better-scroll插件的使用</h3><span class="item__text">2017-12-17</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/CSS/">CSS</a></li><li class="tag-item"><a class="tag-link" href="/tags/Django/">Django</a></li><li class="tag-item"><a class="tag-link" href="/tags/HTML/">HTML</a></li><li class="tag-item"><a class="tag-link" href="/tags/JS/">JS</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/REST-API/">REST API</a></li><li class="tag-item"><a class="tag-link" href="/tags/Vue/">Vue</a></li><li class="tag-item"><a class="tag-link" href="/tags/angularjs/">angularjs</a></li><li class="tag-item"><a class="tag-link" href="/tags/http/">http</a></li><li class="tag-item"><a class="tag-link" href="/tags/业界-云计算-互联网/">业界 云计算 互联网</a></li><li class="tag-item"><a class="tag-link" href="/tags/程序员-建议/">程序员 建议</a></li><li class="tag-item"><a class="tag-link" href="/tags/跨域/">跨域</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>dageger@163.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/qrcode.jpg" alt="logo" title="胡雷的博客"></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, fork by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/DaGeger/" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:dageger@163.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="http://weibo.com/huleidep" target="_blank" title="weibo"><i class="iconfont icon-weibo"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>