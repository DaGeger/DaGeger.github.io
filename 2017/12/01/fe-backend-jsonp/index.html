<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>跨域以及一些解决方法 | HULEI BLOG - 凡心所向 素履所往 生如逆旅 一苇以航</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="hu lei"><meta name="keywords" content="undefined"><meta name="description" content="胡雷的个人博客是一个关注个人博客建设，WEB前端技术，开源云计算等技术信息博客，提供博主在学习成果和工作中经验总结，是一个互联网从业者值得收藏的网站。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta http-equiv="windows-Target" contect="_top"><link rel="canonical" href="http://dageger.cn/2017/12/01/fe-backend-jsonp/index.html"><link rel="icon" type="image/png" href="/img/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="胡雷的博客"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="胡雷的博客" alt="胡雷的博客"><img src="/img/logo.png" alt="胡雷的博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><header class="post__info"><h1 class="post__title">跨域以及一些解决方法</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">DaGege</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2017-12-01</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/跨域/">跨域</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>最近在回顾一些知识，归纳一下以前的笔记再结合各个资料说一下我对跨域和跨域问题的解决方法。<br>产生跨域安全问题不是后台服务器不允许前台调用，<br>其本质是浏览器的同源策略(Same-origin policy)造成的，它是浏览器最基本和最核心的安全机制，同源是指URI scheme、host name、port number相同，借用一下网上的栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">http://www.bear.cn/index.html 调用   http://www.bear.cn/server.php  非跨域</div><div class="line"></div><div class="line">http://www.bear.cn/index.html 调用   http://www.jasmine .cn/server.php  跨域,主域不同</div><div class="line"></div><div class="line">http://gogo.bear.cn/index.html 调用   http://ge.jasmine.cn/server.php  跨域,子域名不同</div><div class="line"></div><div class="line">http://www.bear.cn:2018/index.html 调用   http://www.bear.cn/server.php  跨域,端口不同</div><div class="line"></div><div class="line">https://www.bear.cn/index.html 调用   http://www.bear.cn/server.php  跨域,协议不同</div></pre></td></tr></table></figure><p>如果非同源，将会受到如下限制：</p><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取。</li><li>DOM 无法获得。</li><li>AJAX 请求不能发送。</li></ul><p>浏览器发现前台代码发出了一个非本域的请求，出于安全的考虑，浏览器会做一些校验，如果校验不通过，就无法完成这个请求，抛出请求跨域的错误</p><p><img src="./1.jpg" alt=""></p><h1 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h1><p>JSONP是JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种办法，JSONP看起来和JSON差不多，只不过是被包含在函数调用中的JSON，就像这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callback(&#123;<span class="string">"name"</span>: <span class="string">"Nicholas Bear"</span>&#125;)</div></pre></td></tr></table></figure><p>JSONP由两部分组成：回调函数和数据。回调函数是当浏览器接收到响应时调用的函数，回电函数名一般在请求中指定，数据就是回调函数的参数。如下就是典型的JSONP请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://somewhere-else/json/?callback=handleResponse</div></pre></td></tr></table></figure><p>这里指定的回调函数就是<code>handleResponse()</code><br>JSONP实现原理是通过JS脚本动态生成一个script元素，为其src属性指定一个跨域URL，这里的script元素和img、link元素类似，都有能力不受限制地从其他域加载资源。它并不是官方的协议，而是一种hack手段，看一个简单的栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">    alert(<span class="string">"got message"</span>, res);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>),</div><div class="line">    body = <span class="built_in">document</span>.body;</div><div class="line">script.src = <span class="string">"http://somewhere-else/json/?callback=handleResponse"</span>;</div><div class="line">body.insertBefore(script, body.firstChild);</div></pre></td></tr></table></figure><p>JSONP实现跨域访问非常方便，简单易用，但是也有不足的地方：</p><p>首先，从它的实现方式可以看出来，它是发起一个资源获取请求，是<code>GET</code>类型的，在日常开发中常用的请求类型还有<code>POST</code>，<code>PUT</code>，<code>DELETE</code>，而<code>JSONP</code>只能发起<code>GET</code>请求，是它的一大短板。</p><p>其次，JSONP是从其他域中加载代码并执行，如果其他域不安全，很有可能会在执行的代码中夹杂一些恶意代码，所以在使用JSONP时一定要保证被请求方它安全可靠。</p><p>另外，JSON和JSONP还有一个区别需要特别注意，JSONP请求返回来的不是JSON数据，而是一个JavaScript脚本，为了实现JSONP跨域，需要后台服务器配合。</p><p>最后，由于它的请求类型并不是XHR，就缺少了一些事件处理程序，要追踪JSONP请求是否失败并不容易，或者为JSONP请求增加定时器，超时就视为请求失败，接下来就再次发送请求或者做其他事情，但是每个用户的网络状况并不能保证，这样做也不是万全之策。</p><h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>CORS(Cross-origin resource sharing)跨域源资源共享，是W3C的一个工作草案， 定义了在跨域访问时，浏览器与服务器的沟通方式，具体实现为，使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定跨域请求或响应时应该成功，还是应该失败。</p><p>比如说发起一个GET跨域请求，Content-type是text/plain,在发送跨域请求前，浏览器会为http头部加上一个额外的Origin头部，其中包含了页面的源信息(协议、域名和端口号)，这个额外的Origin决定了服务器是否响应该请求。一个Origin头部实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Origin: https://www.somewhere-else.net</div></pre></td></tr></table></figure><p>如果服务器认可该请求就会在响应头加上<code>Access-Control-Allow-Origin</code>标志字段,值可以是与请求头带来的Origin相同，如果该服务器上的是公共资源，值就是“*”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: https://www.somewhere-else.net</div></pre></td></tr></table></figure><p>如果响应头中没有这个这个字段，说明服务器拒绝了这次跨域请求，会抛出一个错误，但是并不能被xhr的<code>onerror</code>事件捕获。默认情况下跨域请求都是不带凭证的（<code>cookie</code>，<code>HTTP</code>认证及服务端SSL证明等），通过修改xhr对象的<code>withCredentials</code>(IE10以前的版本不支持该属性)设置为true，可以指定某个请求携带凭证。如果服务器允许跨域请求携带凭证响应头部会有标示。<br><code>Access-Control-Allow-Credentials: true</code><br>如果发送的是带凭证的请求，响应头里却没有这个字段，那么浏览器就不会吧响应交给JS，意思是xhr获取到的<code>responseText</code>为空，status为0，这个时候<code>onerror</code>可以捕获到该错误.<br>XHR对象在跨域时也是有限制的:</p><p>不能使用<code>setRequestHeader()</code>来设置头部<br>默认情况下无法发送<code>cookie</code><br>调用<code>getAllResponseHeaders()</code>方法总会返回空字符串</p><h1 id="CORS的实现"><a href="#CORS的实现" class="headerlink" title="CORS的实现:"></a>CORS的实现:</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.onreadystateChange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt;= <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</div><div class="line">            alert(xhr.responseText);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            alert(<span class="string">"error "</span>, xhr.status);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"http://www.somewhere-else.com/page"</span>, <span class="literal">true</span>);</div><div class="line">xhr.send(<span class="literal">null</span>);</div></pre></td></tr></table></figure><p>发送CORS请求和发送普通的xhr对象差别不大, 只需要在地址处写绝对地址即可.跨域所需要做的工作就交给浏览器,对于用户来说是透明.</p><p>IE浏览器是用XDR(XDomainRequest)来实现CORS的,它和XHR相似,但是能提供能安全可靠的跨域通信:</p><p>cookie不会随请求发送,也不会随响应返回<br>只能设置请求头部信息中的<code>Content-Type</code>字段<br>不能访问响应头部信息<br>只支持GET和POST请求</p><p>XDR对象和xhr的使用方法类型,也是创造一个<code>XDomainRequest</code>的实例,调用<code>open()</code>方法,再调用<code>send()</code>方法,但是与xhr对象的<code>open()</code>不同,XDR对象的<code>open()</code>方法只接受两个参数:请求的类型和URL,XDR发送的请求都是异步执行的。而且XDR对象无法访问<code>status</code>属性，所以在使用XDR时一定得通过<code>onerror</code>事件处理程序来捕获错误.</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>跨域请求在发送前,浏览器会检查这个请求是不是简单请求,简单请求满足下面两个条件:</p><ul><li>请求方式为<code>HEAD</code>,<code>POST</code>,<code>GET</code></li><li><p><code>HTTP</code>头部信息包括但不超过以下字段</p><ul><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type(application/x-www-form-urlencode,multipart/form-data,text/plain)</li></ul></li></ul><p>如果满足这些条件，浏览器就会在请求头部增加额外的Origin字段后发送跨域请求。<br><br>响应头一般包含这些字段：</p><ul><li>Access-Control-Allow-Origin，如果浏览器校验通过，这个字段显示的是请求头的Origin值或者*</li><li>Access-Control-Allow-Credential，值为布尔型，表示请求头是否可以携带cookie</li><li>Access-Control-Expose-Headers。拓展的头部信息，浏览器将CORS响应交给JS后，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li></ul><p>注意，如果你想在请求中携带凭证，上面已经说过了，必须将xhr的withCrediential属性设置为true，但有时会报错，错误信息如下图：<br><img src="./2.jpg" alt=""></p><p>错误提示里说如果想要在请求头中携带凭证，那么响应头中的<code>Access-Control-Allow-Origin</code>必须和请求头中的Origin一致，而不能是“*”，解决方法很简单，修改一下后端代码就可以了。</p><h1 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h1><p>CORS通过一种叫做<code>Preflighted Requestes</code>预请求的透明服务器验证机制支持开发人员使用自定义的头部，GET和POST之外的方法，以及不同类型的主题内容。也就是说想要发送这种非简单的跨域请求以前会先发送一个询问请求（携带非简单请求部分信息）来询问服务器是否同意这次非简单请求，这种询问请求使用OPTIONS方法，发送以下头部：</p><ul><li>Origin：和简单请求相同</li><li>Access-Control-Request-Method：请求自身使用的方法</li><li>Access-Control-Request-Headers：这是一个可选头部字段，多个头部以逗号分开。</li></ul><p>发送这个请求以后，服务器可以决定是否允许这种类型的请求。服务器可以通过在响应头中携带以下头部与浏览器沟通：</p><ul><li>Access-Control-Allow-Origin：和简单请求相同</li><li>Access-Control-Allow-Methods：允许的方法</li><li>Access-Control-Allow-Headers: 允许的头部</li><li>Access-Control-Max-Age: 预请求的有效期或者缓存存活时间(秒)</li></ul><p>比如说我现在发送了一个自定义头部字段<code>f-headers1</code>和<code>f-headers2</code>,方法为post的非简单请求,那么首先发送的预请求头部会包含以下信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Origin: http://www.yourhostname.com</div><div class="line">Access-Control-Request-Method: POST</div><div class="line">Access-Control-Request-Headers: f-headers1, f-headers2</div></pre></td></tr></table></figure><p>如果服务器允许这样的非简单请求的跨域访问,返回的响应头会包含这些字段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://www.yourhostname.com</div><div class="line">Access-Control-Allow-Method: POST,GET,PUT,DELETE</div><div class="line">Access-Control-Allow-Headers: f-headers1, f-headers2</div><div class="line">Access-Control-Max-Age: 3600</div></pre></td></tr></table></figure><p>预请求结束后,结果将按照响应中指定的时间缓存起来,下次再发送这样的非简单请求之前就不会再发送询问请求.</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>上述几条都是解决跨域请求资源，但是如果想要获取非同源的<code>cookie</code>，<code>LocalStorage</code>或<code>IndexDB</code>怎么办。<code>cookie</code>是服务器在浏览器上写下的一小段认证信息，大小一般是4k，根据浏览器的不同，每个域允许种下的cookie数量也不同。<code>cookie</code>只有在同源的域下才能共享，但是我们可以通过修改<code>document.domain</code>来共享<code>cookie</code>，如下所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.abc.com</span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">"abc.com"</span>;</div><div class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=bingo"</span>;</div><div class="line"><span class="comment">// b.abc.com</span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">"abc.com"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie); <span class="comment">// "name=bingo"</span></div></pre></td></tr></table></figure><p>但是这种方法前提是这两个网页一级域名相同，一级域名或者叫根域名相同是什么意思呢，比如说这里有个两个域名<code>www.abc.com</code>和<code>www.f.abc.com</code>它们的一级域名都是<code>abc.com</code>。二级域名就是增加了一级包括<code>www</code>，比如说<code>www.zdt.com</code>,<code>netgo.ccdn.com</code>,<code>www.baidu.com</code>等等.三级,四级域名同理.<br>而且这种方法只适用于<code>cookie</code>和<code>iframe</code>.无法获取<code>locastorage</code>和<code>IndexDB</code>.</p><h1 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h1><p>利用iframe解决跨域问题也是一种可取的办法.光是给iframe增加src获取其他页面的资源是不现实,必须借助一些特性实现hack手段.</p><h1 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h1><p>两个iframe之间或者父窗口和子窗口之间。如上述例子里通过改变相同主域的<code>document.domain</code>可以跨域获取cookie，也可以获取对方的全局变量。这种方法和跨域获取cookie一样，只适合具有相同主域的跨域访问。实现原理为相同主域的网站设置相同的<code>document.domain</code>,浏览器就任务它们是同源的,这种方式比较简单，但也有安全问题，如果某一个网站被攻击后，另一个网站就会有安全漏洞</p><h1 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h1><p>window.name,它具有更新了页面的location更新后，值依然不会更变的神奇特性,这让我们跨域访问信息提供了机会。在一个页面中创建一个不同域的iframe，这个iframe的js代码修改它window.name的值，然后再将它变为和父窗口同域的iframe，在父窗口中就可以通过iframe获得修改过后的window.name的值</p><h1 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h1><p><code>location.hash</code>又称片段标识符(Fragment Identitier),它是URL字符中#后面的部分,比如<code>http://www.somewhere-else.com/a.html#fragment</code>,这里的片段标识符就是fragment,URL中的片段标识符改变并不会引起页面刷新.利用<code>location.hash</code>实现跨域访问信息的原理是父窗口可以读写子窗口的URL,子窗口只能读写相同域父窗口的URL.这里想要实现跨域,不同域的子窗口就必须借助一个与父窗口同域的代理. 举个栗子<br><code>a.abc.com/index.html</code>(a)下有一个src为<code>smg.com/index.html</code>(b)的iframe.</p><ol><li><p>a页面给b页面发送数据</p><ul><li>a修改b的src为smg.com/index.html#data</li><li>b页面访问自己的location.hash即可拿到数据</li></ul></li><li><p>b页面给a页面发送数据,b由于不能修改不同域父窗口的URL,所以b页面需要动态创建一个和父窗口同域的iframe来做代理.</p><ul><li>b页面创建一个src为a.abc.com/proxy.html#data的子窗口</li><li>这个proxy页面通过onhashchange(兼容情况)事件监听自己href的变化,事件触发后通过修改a页面的hash来达到传递数据的功能</li><li>a页面访问自己的location.hash即可拿到数据</li></ul></li></ol><h1 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h1><p>不管是iframe和location.hash、document.domain还是window.name都是属于非官方的跨越方法，下面要介绍的就是一个官方方法—postMessage,它是HTML5新增的一个跨文档通信API，它实现了即使不同域也可以跨窗口直接通信的功能，而且只要使用得当，这种方法就很安全。<br>调用对象为父窗口或者的window对象、window.open()的返回值或者是iframe的contentWindow这个属性，这个方法接受两个参数，第一个是要发送的消息，第二个参数是指定接受消息的接收源，可以是*表示所有窗口都可以接收到消息或者是一个url，但只有在协议，域名和端口号都相同才会接收到消息。<br>添加以下代码即可接收<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="comment">// For Chrome, the origin property is in the event.originalEvent</span></div><div class="line">  <span class="comment">// object.</span></div><div class="line">  <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin;</div><div class="line">  <span class="keyword">if</span> (origin !== <span class="string">"http://example.org:8080"</span>)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>事件event对象有三个属性</p><ul><li>data,发送过来的信息</li><li>origin,发送发窗口的origin</li><li>source,对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信</li></ul><div class="post-announce">感谢您的阅读，本文由 <a href="http://dageger.cn">胡雷的博客</a> 版权所有。如若转载，请注明出处：胡雷的博客（<a href="http://dageger.cn/2017/12/01/fe-backend-jsonp/">http://dageger.cn/2017/12/01/fe-backend-jsonp/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2017/11/10/fe-this/" title="this经典题目"><i class="iconfont icon-prev"></i>this经典题目</a></div><div class="post__prev post__prev--right"><a href="/2017/12/17/fe-better-scroll/" title="Vue中better-scroll插件的使用">Vue中better-scroll插件的使用<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <button><i class="iconfont icon-search" for="submit"></i></button></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">胡雷的个人博客是一个关注个人博客建设，WEB前端技术，开源云计算等技术信息博客，提供博主在学习成果和工作中经验总结，是一个互联网从业者值得收藏的网站。</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/后端/">后端</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/前端/">前端</a><span class="block-list-count">14</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/业界/">业界</a><span class="block-list-count">2</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/07/04/fe-loading-demo/" title="5分钟写出一个不错的loading界面"><div class="item__cover"><img src="/2018/07/04/fe-loading-demo/cover.png" alt="5分钟写出一个不错的loading界面"></div><div class="item__info"><h3 class="item__title">5分钟写出一个不错的loading界面</h3><span class="item__text">2018-07-04</span></div></a></li><li class="latest-post-item"><a href="/2018/07/03/fe-crawler/" title="反击爬虫，前端工程师的脑洞可以有多大？"><div class="item__cover"><img src="/2018/07/03/fe-crawler/cover.jpg" alt="反击爬虫，前端工程师的脑洞可以有多大？"></div><div class="item__info"><h3 class="item__title">反击爬虫，前端工程师的脑洞可以有多大？</h3><span class="item__text">2018-07-03</span></div></a></li><li class="latest-post-item"><a href="/2018/03/01/fe-web-http/" title="Web性能优化与HTTP/2"><div class="item__cover"><img src="/2018/03/01/fe-web-http/img-cover.jpg" alt="Web性能优化与HTTP/2"></div><div class="item__info"><h3 class="item__title">Web性能优化与HTTP/2</h3><span class="item__text">2018-03-01</span></div></a></li><li class="latest-post-item"><a href="/2017/12/20/fe-callapply/" title="快速理解JS中apply()和call()原理"><div class="item__cover"><img src="/2017/12/20/fe-callapply/cover.jpg" alt="快速理解JS中apply()和call()原理"></div><div class="item__info"><h3 class="item__title">快速理解JS中apply()和call()原理</h3><span class="item__text">2017-12-20</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/CSS/">CSS</a></li><li class="tag-item"><a class="tag-link" href="/tags/Django/">Django</a></li><li class="tag-item"><a class="tag-link" href="/tags/HTML/">HTML</a></li><li class="tag-item"><a class="tag-link" href="/tags/JS/">JS</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/REST-API/">REST API</a></li><li class="tag-item"><a class="tag-link" href="/tags/Vue/">Vue</a></li><li class="tag-item"><a class="tag-link" href="/tags/angularjs/">angularjs</a></li><li class="tag-item"><a class="tag-link" href="/tags/css/">css</a></li><li class="tag-item"><a class="tag-link" href="/tags/http/">http</a></li><li class="tag-item"><a class="tag-link" href="/tags/业界-云计算-互联网/">业界 云计算 互联网</a></li><li class="tag-item"><a class="tag-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-item"><a class="tag-link" href="/tags/程序员-建议/">程序员 建议</a></li><li class="tag-item"><a class="tag-link" href="/tags/跨域/">跨域</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>dageger@163.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/qrcode.jpg" alt="logo" title="胡雷的博客"></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, fork by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/DaGeger/" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:dageger@163.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="http://weibo.com/huleidep" target="_blank" title="weibo"><i class="iconfont icon-weibo"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>